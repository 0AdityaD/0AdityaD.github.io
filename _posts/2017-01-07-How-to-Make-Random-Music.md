I decided to experiment with random music generation this week using markov chains, a concept I encountered in my data structures class. There are a lot of references out there for random music generation using markov chains on .midi files so I decided to try it out on wav files (mp3 are compressed so that would be impractical). The idea of markov based music generation is to create music that is based off of an input music file. This is done by analyzing trends of music that follows other sequences of music. An obvious issue was that wav files are gigantic - a 6 minute song can exceed 60 MB of data. So performing markov based analysis on such songs isn't instantaneous. I wrote a script that takes as input a wav file and performs a randomization to create a wav file of arbitrary size. A link to the script is [here](https://github.com/0AdityaD/markovmusic/blob/master/generate.py).

Markov chains are a sequence of values where the next value is dependent on the previous value. They can be visualized as multigraphs like the one below taken from wikipedia.

![a markov chain]({{ site.baseurl }}/images/markov.png "a markov chain") 

Each node in the graph is a value in the markov chain and each edge represents a probability that an action or a move to another node exists. Traversing these graphs randomly is known as a random walk.

For music, I represented each seed (node) as a contiguous sequence of **n** bytes in the wav file. These seeds are mapped to a list of bytes in the wav file that follow every occurence of the seed. This is basically an adjacency list representation of the markov graph. To create a new wav file, a random walk is performed on the graph. The resulting sequence of bytes is written to the specified output file. I used the nuscipy and numpy libraries to expedite the read and write processes.

The results were quite varying. I found that the markov concept worked best on files with small variation such as the sound of a monkey chattering. On complex varying songs with multiple themes keys and tracks such as the Eagles song Hotel California, the markov model did not work as well. A random walk yielded a wav file with abrupt transitions between values in the markov chains. This caused the result to sound chunky and unrealistic. One way to fix this would be to round byte values in order to create more intersections in the graph, something I will experiment with later.
